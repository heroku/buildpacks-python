use crate::utils::{self, CommandError};
use crate::{BuildpackError, PythonBuildpack};
use libcnb::build::BuildContext;
use libcnb::data::layer_content_metadata::LayerTypes;
use libcnb::generic::GenericMetadata;
use libcnb::layer::{Layer, LayerResult, LayerResultBuilder};
use libcnb::layer_env::{LayerEnv, ModificationBehavior, Scope};
use libcnb::{Buildpack, Env};
use libherokubuildpack::log::log_info;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::{fs, io};

/// Layer containing the application's Python dependencies, installed using Pip.
pub(crate) struct PipDependenciesLayer<'a> {
    /// Environment variables inherited from earlier buildpack steps.
    pub base_env: &'a Env,
    /// The path to the Pip cache directory, which is stored in another layer since it isn't needed at runtime.
    pub pip_cache_dir: PathBuf,
}

impl Layer for PipDependenciesLayer<'_> {
    type Buildpack = PythonBuildpack;
    type Metadata = GenericMetadata;

    fn types(&self) -> LayerTypes {
        LayerTypes {
            build: true,
            cache: false,
            launch: true,
        }
    }

    // TODO: Explain why we're not caching here.
    fn create(
        &self,
        _context: &BuildContext<Self::Buildpack>,
        layer_path: &Path,
    ) -> Result<LayerResult<Self::Metadata>, <Self::Buildpack as Buildpack>::Error> {
        let layer_env = generate_layer_env(layer_path);
        let env = layer_env.apply(Scope::Build, self.base_env);

        let src_dir = layer_path.join("src");
        fs::create_dir(&src_dir).map_err(PipDependenciesLayerError::CreateSrcDirIo)?;

        log_info("Running pip install");

        utils::run_command(
            Command::new("pip")
                .args([
                    "install",
                    "--cache-dir",
                    &self.pip_cache_dir.to_string_lossy(),
                    // We use a curated Pip version, so skip the update check to speed up Pip invocations,
                    // reduce build log spam and prevent users from thinking they need to manually upgrade.
                    "--disable-pip-version-check",
                    "--no-input",
                    // Prevent warning about the `bin/` directory not being on `PATH`, since it
                    // will be added automatically by libcnb/lifecycle later.
                    "--no-warn-script-location",
                    "--progress",
                    "off",
                    // Install dependencies into the user `site-packages` directory (set by `PYTHONUSERBASE`),
                    // rather than the system `site-packages` directory, since the latter is inside the
                    // Python runtime layer, and we want to keep the application dependencies in a separate
                    // layer to the runtime.
                    "--user",
                    "--requirement",
                    "requirements.txt",
                    // Make pip clone any VCS repositories installed in editable mode into a directory in this layer,
                    // rather than the default of the current working directory (the app dir).
                    "--src",
                    &src_dir.to_string_lossy(),
                ])
                .env_clear()
                .envs(&env)
                // TODO: Explain why we're setting this
                // Using 1980-01-01T00:00:01Z to avoid:
                // ValueError: ZIP does not support timestamps before 1980
                .env("SOURCE_DATE_EPOCH", "315532800"),
        )
        .map_err(PipDependenciesLayerError::PipInstallCommand)?;

        log_info("Pip install completed");

        LayerResultBuilder::new(GenericMetadata::default())
            .env(layer_env)
            .build()
    }
}

/// Environment variables that will be set by this layer.
fn generate_layer_env(layer_path: &Path) -> LayerEnv {
    LayerEnv::new()
        // `PYTHONUSERBASE` overrides the default user base directory, which is used by Python to
        // compute the path of the user `site-packages` directory:
        // https://docs.python.org/3/using/cmdline.html#envvar-PYTHONUSERBASE
        //
        // Setting this:
        //   - Makes `pip install --user` install the dependencies into the current layer rather
        //     than the user's home directory (which would be discarded at the end of the build).
        //   - Allows Python to find the installed packages at import time.
        //
        // It's fine for this directory to be set to the root of the layer, since all of the files
        // created by Pip will be nested inside subdirectories (such as `bin/` or `lib/`), and so
        // won't conflict with the CNB layer metadata related files generated by libcnb.rs.
        .chainable_insert(
            Scope::All,
            ModificationBehavior::Override,
            "PYTHONUSERBASE",
            layer_path,
        )
}

/// Errors that can occur when installing the project's dependencies into a layer using Pip.
#[derive(Debug)]
pub(crate) enum PipDependenciesLayerError {
    CreateSrcDirIo(io::Error),
    PipInstallCommand(CommandError),
}

impl From<PipDependenciesLayerError> for BuildpackError {
    fn from(error: PipDependenciesLayerError) -> Self {
        Self::PipLayer(error)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn pip_dependencies_layer_env() {
        let mut base_env = Env::new();
        base_env.insert("PYTHONUSERBASE", "this-should-be-overridden");

        let layer_env = generate_layer_env(Path::new("/layers/dependencies"));

        assert_eq!(
            utils::environment_as_sorted_vector(&layer_env.apply(Scope::Build, &base_env)),
            vec![("PYTHONUSERBASE", "/layers/dependencies")]
        );
        assert_eq!(
            utils::environment_as_sorted_vector(&layer_env.apply(Scope::Launch, &base_env)),
            vec![("PYTHONUSERBASE", "/layers/dependencies")]
        );
    }
}
